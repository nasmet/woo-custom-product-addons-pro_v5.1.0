"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[8992],{9537:function(t,e,s){s.d(e,{zt:function(){return E},C$:function(){return g},sk:function(){return J}});var r={};s.r(r),s.d(r,{getItem:function(){return k},removeItem:function(){return P},setItem:function(){return v}});class n extends Error{constructor(t,e){void 0===e&&(e=null),super("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."),this.cause=t,this.isNetworkError=!0,this.request=e}}var o=n;class i extends Error{constructor(t,e){var s,r;void 0===e&&(e={}),super(t),this.cause=e.cause,this.cause&&(s=this.cause,r="isNetworkError",Object.prototype.hasOwnProperty.call(s,r))&&(this.isNetworkError=this.cause.isNetworkError)}}var a=i;class h extends Error{constructor(){super("Authorization required"),this.name="AuthError",this.isAuthError=!0}}var p=h;let u;function c(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}var l=0;function d(t){return"__private_"+l+++"_"+t}const m=new Map;var y=d("companionHeaders"),f=d("getUrl");u=Symbol.for("uppy test: getCompanionHeaders");class g{constructor(t,e){Object.defineProperty(this,f,{value:w}),Object.defineProperty(this,y,{writable:!0,value:void 0}),this.uppy=t,this.opts=e,this.onReceiveResponse=this.onReceiveResponse.bind(this),c(this,y)[y]=null==e?void 0:e.companionHeaders}setCompanionHeaders(t){c(this,y)[y]=t}[u](){return c(this,y)[y]}get hostname(){const{companion:t}=this.uppy.getState(),e=this.opts.companionUrl;return(t&&t[e]?t[e]:e).replace(/\/$/,"")}async headers(){return{...{Accept:"application/json","Content-Type":"application/json","Uppy-Versions":`@uppy/companion-client=${g.VERSION}`},...c(this,y)[y]}}onReceiveResponse(t){let{headers:e}=t;const s=this.uppy.getState().companion||{},r=this.opts.companionUrl;e.has("i-am")&&e.get("i-am")!==s[r]&&this.uppy.setState({companion:{...s,[r]:e.get("i-am")}})}async preflight(t){const e=m.get(this.hostname);if(null!=e)return e;const s=["accept","content-type","uppy-auth-token"],r=(async()=>{try{const e=(await fetch(c(this,f)[f](t),{method:"OPTIONS"})).headers.get("access-control-allow-headers");if(null==e||"*"===e)return m.set(this.hostname,s),s;this.uppy.log(`[CompanionClient] adding allowed preflight headers to companion cache: ${this.hostname} ${e}`);const r=e.split(",").map((t=>t.trim().toLowerCase()));return m.set(this.hostname,r),r}catch(t){return this.uppy.log(`[CompanionClient] unable to make preflight request ${t}`,"warning"),m.delete(this.hostname),s}})();return m.set(this.hostname,r),r}async preflightAndHeaders(t){const[e,s]=await Promise.all([this.preflight(t),this.headers()]);return Object.fromEntries(Object.entries(s).filter((t=>{let[s]=t;return!!e.includes(s.toLowerCase())||(this.uppy.log(`[CompanionClient] excluding disallowed header ${s}`),!1)})))}async request(t){let{path:e,method:s="GET",data:r,skipPostResponse:n,signal:i}=t;try{const t=await this.preflightAndHeaders(e),a=await function(){return fetch(...arguments).catch((t=>{throw"AbortError"===t.name?t:new o(t)}))}(c(this,f)[f](e),{method:s,signal:i,headers:t,credentials:this.opts.companionCookiesRule||"same-origin",body:r?JSON.stringify(r):null});return n||this.onReceiveResponse(a),async function(t){if(401===t.status)throw new p;const e=t.json();if(t.ok)return e;let s=`Failed request with status: ${t.status}. ${t.statusText}`;try{const t=await e;s=t.message?`${s} message: ${t.message}`:s,s=t.requestId?`${s} request-Id: ${t.requestId}`:s}catch{}throw new Error(s)}(a)}catch(t){if(null!=t&&t.isAuthError)throw t;throw new a(`Could not ${s} ${c(this,f)[f](e)}`,{cause:t})}}async get(t,e){return void 0===e&&(e=void 0),"boolean"==typeof e&&(e={skipPostResponse:e}),this.request({...e,path:t})}async post(t,e,s){return void 0===s&&(s=void 0),"boolean"==typeof s&&(s={skipPostResponse:s}),this.request({...s,path:t,method:"POST",data:e})}async delete(t,e,s){return void 0===e&&(e=void 0),"boolean"==typeof s&&(s={skipPostResponse:s}),this.request({...s,path:t,method:"DELETE",data:e})}}function w(t){return/^(https?:|)\/\//.test(t)?t:`${this.hostname}/${t}`}function v(t,e){return new Promise((s=>{localStorage.setItem(t,e),s()}))}function k(t){return Promise.resolve(localStorage.getItem(t))}function P(t){return new Promise((e=>{localStorage.removeItem(t),e()}))}function b(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}g.VERSION="3.2.1";var T=0;function A(t){return"__private_"+T+++"_"+t}var O=A("refreshingTokenPromise"),$=A("getAuthToken"),S=A("removeAuthToken");class E extends g{constructor(t,e){super(t,e),Object.defineProperty(this,S,{value:I}),Object.defineProperty(this,$,{value:R}),Object.defineProperty(this,O,{writable:!0,value:void 0}),this.provider=e.provider,this.id=this.provider,this.name=this.opts.name||(t=>t.split("-").map((t=>t.charAt(0).toUpperCase()+t.slice(1))).join(" "))(this.id),this.pluginId=this.opts.pluginId,this.tokenKey=`companion-${this.pluginId}-auth-token`,this.companionKeysParams=this.opts.companionKeysParams,this.preAuthToken=null}async headers(){const[t,e]=await Promise.all([super.headers(),b(this,$)[$]()]),s={};return e&&(s["uppy-auth-token"]=e),this.companionKeysParams&&(s["uppy-credentials-params"]=btoa(JSON.stringify({params:this.companionKeysParams}))),{...t,...s}}onReceiveResponse(t){super.onReceiveResponse(t);const e=this.uppy.getPlugin(this.pluginId),s=e.getPluginState().authenticated?401!==t.status:t.status<400;return e.setPluginState({authenticated:s}),t}async setAuthToken(t){return this.uppy.getPlugin(this.pluginId).storage.setItem(this.tokenKey,t)}async ensurePreAuth(){if(this.companionKeysParams&&!this.preAuthToken&&(await this.fetchPreAuthToken(),!this.preAuthToken))throw new Error("Could not load authentication data required for third-party login. Please try again later.")}authUrl(t){void 0===t&&(t={});const e=new URLSearchParams(t);return this.preAuthToken&&e.set("uppyPreAuthToken",this.preAuthToken),`${this.hostname}/${this.id}/connect?${e}`}refreshTokenUrl(){return`${this.hostname}/${this.id}/refresh-token`}fileUrl(t){return`${this.hostname}/${this.id}/get/${t}`}async request(){await b(this,O)[O];try{return await super.request(...arguments)}catch(t){if(!t.isAuthError)throw t;return await b(this,O)[O],b(this,O)[O]=(async()=>{try{const t=await super.request({path:this.refreshTokenUrl(),method:"POST"});await this.setAuthToken(t.uppyAuthToken)}finally{b(this,O)[O]=void 0}})(),await b(this,O)[O],super.request(...arguments)}}async fetchPreAuthToken(){if(this.companionKeysParams)try{const t=await this.post(`${this.id}/preauth/`,{params:this.companionKeysParams});this.preAuthToken=t.token}catch(t){this.uppy.log(`[CompanionClient] unable to fetch preAuthToken ${t}`,"warning")}}list(t,e){return this.get(`${this.id}/list/${t||""}`,e)}async logout(){const t=await this.get(`${this.id}/logout`);return await b(this,S)[S](),t}static initPlugin(t,e,s){if(t.type="acquirer",t.files=[],s&&(t.opts={...s,...e}),e.serverUrl||e.serverPattern)throw new Error("`serverUrl` and `serverPattern` have been renamed to `companionUrl` and `companionAllowedHosts` respectively in the 0.30.5 release. Please consult the docs (for example, https://uppy.io/docs/instagram/ for the Instagram plugin) and use the updated options.`");if(e.companionAllowedHosts){const s=e.companionAllowedHosts;if(!("string"==typeof s||Array.isArray(s)||s instanceof RegExp))throw new TypeError(`${t.id}: the option "companionAllowedHosts" must be one of string, Array, RegExp`);t.opts.companionAllowedHosts=s}else/^(?!https?:\/\/).*$/i.test(e.companionUrl)?t.opts.companionAllowedHosts=`https://${e.companionUrl.replace(/^\/\//,"")}`:t.opts.companionAllowedHosts=new URL(e.companionUrl).origin;t.storage=t.opts.storage||r}}async function R(){return this.uppy.getPlugin(this.pluginId).storage.getItem(this.tokenKey)}async function I(){return this.uppy.getPlugin(this.pluginId).storage.removeItem(this.tokenKey)}var j=s(4800);let q,C;function U(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}var _=0;function H(t){return"__private_"+_+++"_"+t}var K=H("queued"),N=H("emitter"),x=H("isOpen"),F=H("socket"),L=H("handleMessage");q=Symbol.for("uppy test: getSocket"),C=Symbol.for("uppy test: getQueued");class J{constructor(t){Object.defineProperty(this,K,{writable:!0,value:[]}),Object.defineProperty(this,N,{writable:!0,value:j()}),Object.defineProperty(this,x,{writable:!0,value:!1}),Object.defineProperty(this,F,{writable:!0,value:void 0}),Object.defineProperty(this,L,{writable:!0,value:t=>{try{const e=JSON.parse(t.data);this.emit(e.action,e.payload)}catch(t){}}}),this.opts=t,t&&!1===t.autoOpen||this.open()}get isOpen(){return U(this,x)[x]}[q](){return U(this,F)[F]}[C](){return U(this,K)[K]}open(){null==U(this,F)[F]&&(U(this,F)[F]=new WebSocket(this.opts.target),U(this,F)[F].onopen=()=>{for(U(this,x)[x]=!0;U(this,K)[K].length>0&&U(this,x)[x];){const t=U(this,K)[K].shift();this.send(t.action,t.payload)}},U(this,F)[F].onclose=()=>{U(this,x)[x]=!1,U(this,F)[F]=null},U(this,F)[F].onmessage=U(this,L)[L])}close(){var t;null==(t=U(this,F)[F])||t.close()}send(t,e){U(this,x)[x]?U(this,F)[F].send(JSON.stringify({action:t,payload:e})):U(this,K)[K].push({action:t,payload:e})}on(t,e){U(this,N)[N].on(t,e)}emit(t,e){U(this,N)[N].emit(t,e)}once(t,e){U(this,N)[N].once(t,e)}}},4060:function(t,e,s){s.d(e,{Z:function(){return h}});var r=s(8596);function n(t,e){if(!Object.prototype.hasOwnProperty.call(t,e))throw new TypeError("attempted to use private field on non-instance");return t}var o=0;function i(t){return"__private_"+o+++"_"+t}var a=i("queueRequestSocketToken");class h extends r.Z{constructor(){super(...arguments),Object.defineProperty(this,a,{writable:!0,value:void 0})}setQueueRequestSocketToken(t){n(this,a)[a]=t}async uploadRemoteFile(t,e){void 0===e&&(e={});try{if(t.serverToken)return await this.connectToServerSocket(t);const s=await n(this,a)[a](t).abortOn(e.signal);if(!this.uppy.getState().files[t.id])return;return this.uppy.setFileState(t.id,{serverToken:s}),await this.connectToServerSocket(this.uppy.getFile(t.id))}catch(e){var s;if("AbortError"===(null==e||null==(s=e.cause)?void 0:s.name))return;throw this.uppy.setFileState(t.id,{serverToken:void 0}),this.uppy.emit("upload-error",t,e),e}}}}}]);